## 思考题

### 启动顺序

1. 段寄存器的字段含义和功能有哪些？

> 1.segment register[15-3]: index，表示段描述符的编号。

> 2.segment register[2-2]: tabel indicator，表示使用的表，0表示GDT，1表示LDT

> 3.segment register[1-0]: requested privilege level, 表示访问该程序段的请求特权级，与当前程序段的CPL取max之后作为与dpl比较的特权值。

2. 描述符特权级DPL、当前特权级CPL和请求特权级RPL的含义是什么？在哪些寄存器中存在这些字段？对应的访问条件是什么？
3.分析可执行文件格式elf的格式（无需回答）

> DPL:存储在描述符中的权限位，用于描述代码的所属的特权等级，也就是代码真正的特权级。

> CPL:表示当前正在执行的代码所处的特权级。保存在CS中的最低两位，是针对CS而言的。

> RPL:保存在选择子的最低两位，所说的是进程对段访问的请求权限，是当前进程想要的请求权限。

> 访问条件：max(RPL,CPL)<=DPL

### 4.2 C函数调用的实现

### 4.4 x86中断处理过程

1.中断处理中硬件压栈内容？用户态中断和内核态中断的硬件压栈有什么不同？

> 压栈内容：error code， eip， cs， eflags， esp， ss

> 不同：内核态不需要压esp和ss.

2.为什么在用户态的中断响应要使用内核堆栈？

> 需要进行栈的转换，因为处理是在内核态进行。

3.trap类型的中断门与interrupt类型的中断门有啥设置上的差别？如果在设置中断门上不做区分，会有什么可能的后果?

> type字段有区别。如果不区分，则可能会重复触发或者丢失中断。

### 4.8 练习四和练习五ucore内核映像加载和函数调用栈分析

1.在kdebug.c文件中用到的函数read_ebp是内联的，而函数read_eip不是内联的。为什么要设计成这样？

> 做完实验再说吧。

### 练习六  完善中断初始化和处理 

1.CPU加电初始化后中断是使能的吗？为什么？

> 不是，需要加载完IDT才能开启中断使能。因为一开始并不能识别处理中断。